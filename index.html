<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Scooter Dash ‚Äì Fixed Edition</title>
<style>
body {
    margin: 0;
    background: #050505;
    color: white;
    font-family: Arial, sans-serif;
    text-align: center;
}
canvas {
    display: block;
    margin: auto;
    background: linear-gradient(#0c0c12, #151525);
}
</style>
</head>
<body>

<h2>üõ¥ Scooter Dash ‚Äì Level <span id="lvl">1</span>/10</h2>
<p>Space / Click = Jump ‚Ä¢ Gravity Portals</p>

<canvas id="game" width="1000" height="450"></canvas>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const lvlText = document.getElementById("lvl");

let level = 1;
let gameOver = false;
let gravityDir = 1;
let scrollX = 0;

/* ================= PLAYER ================= */
const player = {
    x: 150,
    y: 280,
    w: 28,
    h: 42,
    vy: 0,
    onGround: false,
    rot: 0
};

const GRAVITY = 0.7;
const JUMP = -13;
const SPEED = 4;

/* ================= LEVEL DATA ================= */
const LEVELS = [
    { length: 3000, platforms: [[0,340,3000,30]], spikes:[600,900,1300], portals:[] },
    { length: 3200, platforms: [[0,340,500,30],[650,300,250,20],[1100,340,500,30]], spikes:[550,1000], portals:[] },
    { length: 3500, platforms: [[0,340,400,30],[550,280,200,20],[900,340,400,30]], spikes:[380,820], portals:[700] },
    { length: 3800, platforms: [[0,340,350,30],[520,260,220,20],[900,340,400,30]], spikes:[300,760], portals:[600] },
    { length: 4200, platforms: [[0,340,300,30],[480,300,220,20],[820,260,220,20]], spikes:[260,640], portals:[] },
    { length: 4600, platforms: [[0,340,260,30],[420,260,200,20],[760,340,300,30]], spikes:[220,600,880], portals:[500] },
    { length: 5000, platforms: [[0,340,220,30],[360,300,200,20],[720,260,200,20]], spikes:[200,580], portals:[450] },
    { length: 5400, platforms: [[0,340,200,30],[340,260,180,20],[680,300,200,20]], spikes:[180,560,820], portals:[430] },
    { length: 5800, platforms: [[0,340,180,30],[300,280,180,20],[640,240,180,20]], spikes:[160,520], portals:[400,700] },
    { length: 6200, platforms: [[0,340,160,30],[280,260,160,20],[600,300,160,20]], spikes:[140,480,760], portals:[360,640] }
];

let platforms = [];
let spikes = [];
let portals = [];
let usedPortals = new Set();

/* ================= LOAD LEVEL ================= */
function loadLevel() {
    const L = LEVELS[level - 1];
    scrollX = 0;
    gravityDir = 1;
    usedPortals.clear();
    gameOver = false;

    platforms = L.platforms.map(p => ({x:p[0],y:p[1],w:p[2],h:p[3]}));
    spikes = L.spikes.map(x => ({x,y:330}));
    portals = L.portals.map(x => ({x,w:20}));

    player.y = 280;
    player.vy = 0;
    lvlText.textContent = level;
}
loadLevel();

/* ================= INPUT ================= */
function jump() {
    if (player.onGround && !gameOver) {
        player.vy = JUMP * gravityDir;
        player.onGround = false;
    }
}
document.addEventListener("keydown", e => {
    if (e.code === "Space") jump();
    if (e.code === "KeyR" && gameOver) loadLevel();
});
canvas.addEventListener("click", jump);

/* ================= UPDATE ================= */
function update() {
    if (gameOver) return;

    scrollX += SPEED;

    // Physics
    player.vy += GRAVITY * gravityDir;
    player.y += player.vy;
    player.rot += 0.05;
    player.onGround = false;

    // Platforms
    platforms.forEach(p => {
        const px = p.x - scrollX;
        if (
            player.x < px + p.w &&
            player.x + player.w > px &&
            gravityDir === 1 &&
            player.y + player.h >= p.y &&
            player.y + player.h <= p.y + 15
        ) {
            player.y = p.y - player.h;
            player.vy = 0;
            player.onGround = true;
        }
    });

    // Spikes
    spikes.forEach(s => {
        const sx = s.x - scrollX;
        if (
            player.x < sx + 30 &&
            player.x + player.w > sx &&
            player.y + player.h > s.y
        ) gameOver = true;
    });

    // Gravity portals (1x trigger)
    portals.forEach((p,i) => {
        const px = p.x - scrollX;
        if (
            player.x < px + p.w &&
            player.x + player.w > px &&
            !usedPortals.has(i)
        ) {
            gravityDir *= -1;
            usedPortals.add(i);
        }
    });

    // Drop / Out of bounds
    if (player.y > canvas.height || player.y < -100) gameOver = true;

    // Level end
    if (scrollX >= LEVELS[level-1].length) {
        level++;
        if (level > 10) {
            alert("üèÜ Alle 10 Level geschafft!");
            level = 1;
        }
        loadLevel();
    }
}

/* ================= DRAW ================= */
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Background grid
    ctx.fillStyle = "#111";
    for(let i=0;i<canvas.width;i+=80){
        ctx.fillRect(i,0,40,450);
    }

    // Platforms
    ctx.fillStyle = "#2a2a2a";
    platforms.forEach(p => {
        const px = p.x - scrollX;
        ctx.fillRect(px,p.y,p.w,p.h);
        ctx.fillStyle="#444";
        ctx.fillRect(px,p.y,p.w,4);
        ctx.fillStyle="#2a2a2a";
    });

    // Spikes
    ctx.fillStyle="#ff3355";
    spikes.forEach(s => {
        const sx = s.x - scrollX;
        ctx.beginPath();
        ctx.moveTo(sx,s.y+30);
        ctx.lineTo(sx+15,s.y);
        ctx.lineTo(sx+30,s.y+30);
        ctx.fill();
    });

    // Gravity portals
    ctx.fillStyle="rgba(150,80,255,0.4)";
    portals.forEach(p=>{
        const px=p.x-scrollX;
        ctx.fillRect(px,0,p.w,450);
    });

    // Player
    ctx.save();
    ctx.translate(player.x+player.w/2,player.y+player.h/2);
    ctx.rotate(player.rot);
    ctx.fillStyle="#00ffd0";
    ctx.fillRect(-14,-21,28,42);
    ctx.fillStyle="#fff";
    ctx.fillRect(-24,20,48,5);
    ctx.restore();

    if (gameOver) {
        ctx.fillStyle="white";
        ctx.font="32px Arial";
        ctx.fillText("üíÄ GAME OVER",390,200);
        ctx.font="16px Arial";
        ctx.fillText("Press R to Restart",415,230);
    }
}

/* ================= LOOP ================= */
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
